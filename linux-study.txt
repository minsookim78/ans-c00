Git Working Flow - 작업 흐름

여러분의 로컬 저장소는 git이 관리하는 세 그루의 나무로 구성되어 있습니다. 

첫번째 나무인 작업 디렉토리(Working directory)는 로컬(실제) 파일들로 이루어져있고, 두번째 나무인 인덱스(Index)는 준비 영역(staging area)의 역할을 하며, 마지막 나무인 HEAD는 최종 확정본(commit)을 나타냅니다.



출처: https://webclub.tistory.com/317 [Web Club]

$ git branch -> 로컬 branch 확인
 $ git branch -r 서버 branch 확인 
 $ git checkout -b 브랜치명 브랜치를 만들고 바로 이동 
 $ git branch -d(D) test 브랜치 삭제 
 $ git status 현재상태(머지나 추가사항) 확인 $ git add 경로 에러를 해결하고 추가하여 에러해결 $ git stash 임시저장 $ git stash pop 임시저장한파일 불러오기 $ git remote prune origin 깃랩에서 삭제한거 서버와 동기화 $ git push origin :브랜치네임 서버에서 삭제하기 $ git remote $ git push origin dev $ git config http.postBuffer 104857600 git오류시 해결 $ git merge --squash dev $ git merge --no-ff feature- : 새로운 가지 따서 merge(관리상 용이) $ git clone 주소 $ git remote set-url origin 주소 : gitlap 저장소 변경시 설정 $ git remote -v : gitlap 저장소 주소 확인 // 고아 브랜치 만드는 방법 $ git checkout master $ git checkout --orphan c_YYMMDD_CAMPAIGNNAME $ git rm -rf . $ git push origin c_YYMMDD_CAMPAIGNNAME

출처: https://webclub.tistory.com/317 [Web Club]


Linux

gerp 명령어 사용법
find 명령어 사용법
네트워크 설정법
FTP
Vi
사용자 계정/ 그룹자 계정 생성/수정법
허가/소유권/특수권한 명령어
파일 압축 / 해제
HDD 및 파티션 작업
디스크관리
마운트 작업(autoMount 설정)
process runlevel kernel
관리자 응급 복구 작업
관리자 비밀번호 찾기
시스템 부팅 변경시서비스 서버 구축 과장
FTP tjqltm wkrdjq dlgo
NFS서비스
DNS 서비스 구축
WEB서비스 구축
DB시스템 구축
PHP웹서버 프로그래밍을 통한 DB 시스템 관리상제로보드 웹 사이트 작업


1. find 명령어.
리눅스 find 명령어



find는 리눅스에서 파일 및 디렉토리를 검색할 때 사용하는 명령입니다. 이름 그대로 리눅스에서 접근할 수 있는 파일 시스템에서, 파일 및 디렉토리를 "찾는(find)" 것이죠.



그런데 리눅스 파일 시스템은 구조가 아주 복잡합니다. 아주 많은 수의 파일과 디렉토리가 저장되어 있죠. 이 중에는, 비슷한 이름의 파일과 동일한 확장자를 가진 파일, 그리고 종류가 다양한 파일들이 존재합니다. 이에 따라, 복잡한 구조에서 원하는 파일을 가능한 정확히 찾을 수 있도록, find 명령에는 다양한 옵션이 존재합니다.



여기서는 find 명령의 기본적인 사용법에 대해 설명하고, 여러 옵션을 사용하여 파일 및 디렉토리를 검색하는 방법에 대해 알아보겠습니다.

2. find 명령어 옵션.
find 명령에는 몇 가지 옵션과 많은 수의 표현식(Expression)이 존재하는데요. 일반적인 리눅스 명령어와는 조금 다르게, find 명령은 옵션보다 표현식이 더 많이 사용됩니다. find 명령의 검색 결과가 지정된 표현식의 조합에 따라 결정되기 때문입니다.



여기서는 옵션에 관한 내용은 따로 정리하지 않고, 표현식에 대한 내용만 정리하였습니다. 그리고 모든 표현식을 설명하려면 지면이 한참 모자라니, 자주 사용하는 표현식에 대해서만 정리하였습니다. (find 명령에 대한 더 자세한 옵션은 "find --help" 명령을 통해 확인할 수 있습니다.)



    find [OPTION...] [PATH] [EXPRESSION...]
      OPTION
        -P        : 심볼릭 링크를 따라가지 않고, 심볼릭 링크 자체 정보 사용.
        -L        : 심볼릭 링크에 연결된 파일 정보 사용.
        -H        : 심볼릭 링크를 따라가지 않으나, Command Line Argument를 처리할 땐 예외.
        -D        : 디버그 메시지 출력.
      EXPRESSION
        -name     : 지정된 문자열 패턴에 해당하는 파일 검색.
        -empty    : 빈 디렉토리 또는 크기가 0인 파일 검색.
        -delete   : 검색된 파일 또는 디렉토리 삭제.
        -exec     : 검색된 파일에 대해 지정된 명령 실행.
        -path     : 지정된 문자열 패턴에 해당하는 경로에서 검색.
        -print    : 검색 결과를 출력. 검색 항목은 newline으로 구분. (기본 값)
        -print0   : 검색 결과를 출력. 검색 항목은 null로 구분.
        -size     : 파일 크기를 사용하여 파일 검색.
        -type     : 지정된 파일 타입에 해당하는 파일 검색.
        -mindepth : 검색을 시작할 하위 디렉토리 최소 깊이 지정.
        -maxdepth : 검색할 하위 디렉토리의 최대 깊이 지정.
        -atime    : 파일 접근(access) 시각을 기준으로 파일 검색.
        -ctime    : 파일 내용 및 속성 변경(change) 시각을 기준으로 파일 검색.
        -mtime    : 파일의 데이터 수정(modify) 시각을 기준으로 파일 검색.
또한 표현식 사용 시 연산자(Operator)를 사용하여 "두 개 이상의 표현식" 조합이 가능한데요, find 명령에서 사용할 수 있는 연산자에는 아래와 같은 것들이 존재합니다.



표현식	설명
(expression)	expression 우선순위 지정.
!expression
-not expression	expression 결과에 NOT 연산.
expression -a expression
expression -and expression
expression expression	expression 간 AND 연산.
expression -o expression
expression -or expression	expression 간 OR 연산.
표에서 알 수 있듯이 find 명령에서 두 개 이상의 표현식을 사용할 때 연산자를 지정하지 않으면, 기본적으로 -a (AND)가 적용됩니다. ("-empty -print" = "-empty -a -print")

3. find 명령 사용 예제.
현재 디렉토리 내에서 지정된 이름의 파일을 찾는 것은 간단합니다. find 명령 뒤에 파일이름을 지정하기만 하면 됩니다.

$ ls
FILE_1  FILE_2  FILE_3
$ find FILE_1
FILE_1
하지만 앞에서도 간단히 설명했듯이, 일반적인 리눅스 파일 시스템은 그 구조가 매우 복잡합니다. 그래서 현재 디렉토리에 있는 파일을 찾기 위해 find 명령을 사용하는 경우는 드물고, 지정된 디렉토리에 포함된 디렉토리 및 패턴으로 지정된 파일 이름으로 파일을 찾는 경우가 많죠. (현재 디렉토리에 있는 파일 검색은 주로 ls 명령 사용) 이에 따라 find 명령에 사용하는 옵션도 조금 더 복잡하게 지정되는데, 보통 아래의 기본 형식을 변형해서 사용합니다.

$ find . -name "FILE"


이 명령의 의미는 "현재 디렉토리(.)에서 "FILE"이라는 이름을 가진(-name "FILE") 파일을 찾아라." 입니다. 이 때 검색되는 경로는 현재 디렉토리와 현재 디렉토리에 포함된 하위 디렉토리를 모두 포함합니다.



아래 표는 find 명령 사용 예제를 정리한 것입니다. 각 항목의 링크를 선택하면, 좀 더 자세한 설명과 사용 예제를 확인할 수 있습니다.

find 사용 예	명령어 옵션
현재 디렉토리에 있는 파일 및 디렉토리 리스트 표시	find
대상 디렉토리에 있는 파일 및 디렉토리 리스트 표시	find [PATH]
현재 디렉토리 아래 모든 파일 및 하위 디렉토리에서 파일 검색	find . -name [FILE]
전체 시스템(루트 디렉토리)에서 파일 검색	find / -name [FILE]
파일 이름이 특정 문자열로 시작하는 파일 검색	find . -name "STR*"
파일 이름에 특정 문자열이 포함된 파일 검색	find . -name "*STR*"
파일 이름이 특정 문자열로 끝나는 파일 검색	find . -name "*STR"
빈 디렉토리 또는 크기가 0인 파일 검색	find . -empty
특정 확장자를 가진 모든 파일 검색 후 삭제	find . -name "*.EXT" -delete
검색된 파일 리스트를 줄 바꿈 없이 이어서 출력하기	find . -name [FILE] -print0
파일 또는 디렉토리만 검색하기	find . -name [FILE] -type f
파일 크기를 사용하여 파일 검색	find . -size +[N]c -and -size -[M]c
검색된 파일에 대한 상세 정보 출력. (find + ls)	find . -name [FILE] -exec ls -l {} \;
검색된 파일의 라인 수 출력. (find + wc)	find . -name [FILE] -exec wc-l {} \;
검색된 파일에서 문자열 찾기. (find + grep)	find . -name [FILE] -exec grep "STR" {} \;
검색 결과를 파일로 저장. (find, redirection)	find . -name [FILE] > [SAVE_FILE]
검색 중 에러 메시지 출력하지 않기 (find, redirection)	find . -name [FILE] 2> /dev/null
하위 디렉토리 검색하지 않기	find . -maxdepth 1 -name [FILE]
검색된 파일 복사. (find + cp)	find . -name [FILE] -exec cp {} [PATH] \;
3.1 현재 디렉토리에 있는 파일 및 디렉토리 리스트 표시.
아무런 옵션없이 find 명령만 사용하면 현재 디렉토리(하위 디렉토리 포함)에 있는 모든 파일과 디렉토리를 표시합니다. 주로 디렉토리 파일 리스트를 다른 명령으로 전달하여 처리하고자 할 때 사용합니다.

$ find                        # 현재 디렉토리의 파일 및 디렉토리 출력
$ find -print0                # 현재 디렉토리의 모든 내용을 줄 바꿈 없이 출력.
$ find
.
./FILE_1
./DIR_1
./DIR_1/FILE_1
./DIR_1/FILE_2
./DIR_1/FILE_3
./FILE_2
./FILE_3
3.2 대상 디렉토리에 있는 파일 및 디렉토리 리스트 표시.
find 명령 다음에 디렉토리를 지정하여, 대상 디렉토리에 있는 파일 및 디렉토리 리스트를 표시합니다.

$ find [PATH]                 # PATH에 있는 파일 및 디렉토리 리스트 표시.
$ find DIR_1
DIR_1
DIR_1/FILE_1
DIR_1/FILE_2
DIR_1/FILE_3
3.3 현재 디렉토리 아래 모든 파일 및 하위 디렉토리에서 파일 검색
현재 디렉토리에 포함된 모든 하위 디렉토리 및 파일에서 지정된 파일을 검색하려면 아래 명령을 수행하면 됩니다.

$ find . -name [NAME]         # 현재 디렉토리 아래 모든 파일 및 디렉토리 검색.
$ find . -name "FILE_1"
./FILE_1
./DIR_1/FILE_1
3.4 전체 시스템(루트 디렉토리)에서 파일 검색
디렉토리 경로를 루트(/)로 지정하여 전체 시스템 중 특정 파일을 검색할 수 있습니다.

$ find / -name [NAME]         # 루트 디렉토리에서 파일 이름으로 검색.
$ find / -name "FILE_1"
/home/ppotta/FILE_1
/home/ppotta/DIR_1/FILE_1
3.5 파일 이름이 특정 문자열로 시작하는 파일 검색
찾을 파일 이름에 와일드 카드(*) 문자를 포함하여 특정 문자열로 시작하는 파일을 검색할 수 있습니다.

$ find . -name "STR*"         # 지정된 문자열로 시작하는 파일 검색.
$ ls
A_FILE  B_FILE  C_FILE
$ find . -name "B*"
./B_FILE
3.6 파일 이름에 특정 문자열이 포함된 파일 검색
찾을 파일 이름 시작과 끝에 와일드 카드(*) 문자를 포함하여 특정 문자열이 포함된 파일을 검색할 수 있습니다.

$ find . -name "*STR*"        # 지정된 문자열이 포함된 파일 검색.
$ ls
A_FILE  B_FILE  C_FILE
$ find . -name "*IL*"
./B_FILE
./C_FILE
./A_FILE
3.7 파일 이름이 특정 문자열로 끝나는 파일 검색 (파일 확장자로 검색)
찾을 파일 이름 끝에 와일드 카드(*) 문자를 사용하여 특정 문자열로 끝나는 파일을 검색할 수 있습니다. 확장자가 일치하는 파일을 검색할 때 유용합니다.

$ find . -name "*STR"         # 지정된 문자열로 끝나는 파일 검색.
$ ls
A.c  A.h  B.c  B.h
$ find . -name "*.c"
./A.c
./B.c
3.8 빈 디렉토리 또는 크기가 0인 파일 검색
"-empty" 표현식을 사용하여, 빈 디렉토리 또는 크기가 0인 파일을 검색할 수 있습니다.

$ find . -empty               # 빈 디렉토리 또는 크기가 0인 파일 검색.
$ find . -name TMP -empty     # TMP라는 이름의 빈 디렉토리 또는 크기가 0인 파일 검색.
$ ls
A.c  A.h  B.c  B.h  DIR1
$ ls ./DIR1
$ find . -empty
./DIR1
3.9 특정 확장자를 가진 모든 파일 검색 후 삭제
"-delete" 표현식을 사용하여, 검색된 파일 및 디렉토리를 삭제할 수 있습니다. 만약 검색 대상에 디렉토리가 포함된 경우, 디렉토리가 비어 있지 않으면 해당 디렉토리는 삭제되지 않습니다.

$ find . -name "*.EXT" -delete          # 확장자 검색 후 파일 삭제.
$ ls
A.c  A.h  B.c  B.h
$ find . -name "*.h" -delete
$ ls
A.c  B.c
3.10 검색된 파일 리스트를 줄 바꿈 없이 이어서 출력하기
"-print0" 표현식을 사용하여, 검색 결과를 줄바꿈(newline) 없이 이어서 출력할 수 있습니다.

$ find . -name [FILE] -print0           # 검색된 결과를 줄 바꿈 없이 출력.
$ find . -name [FILE] -print            # 검색된 결과를 줄 바꿈으로 구분하여 출력.
$ ls
A.c  A.h  B.c  B.h
$ find . -name "*.h" -print0
./B.h./A.h
3.11 파일 또는 디렉토리만 검색하기
"-type" 표현식을 사용하여, 파일 종류를 지정하여 검색할 수 있습니다.

b : block special
c : character special
d : directory
f : regular file
l : symbolic link
p : FIFO
s : socket
$ find . -name build -type f            # build라는 이름의 일반 파일 검색.
$ find . -name PROJ -type d             # PROJ라는 이름의 디렉토리만 검색
$ ls
DIR_1  DIR_2  FILE_1  FILE_2
$ find . -name "*_1" -type f
./FILE_1
$ find . -name "*_2" -type d
./DIR_2
3.12 파일 크기를 사용하여 파일 검색.
파일 크기를 사용하여 파일을 찾으려면, "-size" 표현식을 사용합니다.



"-size" 표현식은 기본적으로 block 단위(512B)의 크기를 사용하게 되어 있는데, 파일 크기 값 뒤에 'c' 또는 'k'를 붙임으로써 바이트 단위 또는 킬로바이트의 크기 값을 지정할 수 있습니다. (b:block, c:bytes, w:2bytes, k:kbytes, M:mbytes, G:gbytes)



그리고 파일 크기를 비교할 때, "-size" 표현식 두 개를 조합하여 "초과" 또는 "미만"에 대한 내용도 지정할 수 있습니다. 이 때는 크기 값 앞에 +(초과) 또는 -(미만) 기호를 사용합니다.
예를 들어 1024 바이트보다 크고 2048바이트보다 작은 파일을 검색할 때, "-size +1024c -size -2048c" 표현식을 사용합니다.



$ find . -size 1024c                    # 파일 크기가 1024 바이트인 파일 검색.
$ find . -size +1024c                   # 파일 크기가 1024 바이트를 초과하는 파일 검색.
$ find . -size -1024c                   # 파일 크기가 1024 바이트 미만인 파일 검색.
$ find . -size +1024c -size -2048c      # 파일 크기가 1024 바이트 초과, 2048 바이트 미만인 파일 검색
$ ls -la
total 24
drwxr-xr-x 2 ppotta ppotta 4096 Mar 19 01:10 .
drwxr-xr-x 5 ppotta ppotta 4096 Mar 19 00:54 ..
-rw-r--r-- 1 ppotta ppotta   11 Mar 19 01:09 A.c
-rw-r--r-- 1 ppotta ppotta    3 Mar 19 00:44 A.h
-rw-r--r-- 1 ppotta ppotta   11 Mar 19 01:10 B.c
-rw-r--r-- 1 ppotta ppotta    3 Mar 19 00:44 B.h
$ find . -size +5c -size -12c
./A.c
./B.c
3.13 검색된 파일에 대한 상세 정보 출력. (find + ls)
"-exec" 표현식은 find 명령으로 검색된 결과를 사용해 다른 명령을 실행할 수 있게 만들어 줍니다.



아래 예제는 find 명령으로 검색된 내용 ls -l 명령으로 전달하여 파일 상세 정보를 표시하게 만드는 것입니다.

$ find . -name "*.c" -exec ls -l {} \;            # 현재 디렉토리에서 c 확장자 파일 상세 정보 출력.
$ ls
A.c  A.h  B.c  B.h
$ find . -name "*.c" -exec ls -l {} \;
-rw-r--r-- 1 ppotta ppotta 11 Mar 19 01:09 ./A.c
-rw-r--r-- 1 ppotta ppotta 11 Mar 19 01:10 ./B.c
3.14 검색된 파일의 라인 수 출력. (find + wc)
find 명령과 wc 명령(Word Count)을 조합하여 검색 파일의 문자 수 또는 라인 수를 계산하여 출력할 수 있습니다.



$ find . -name "*.c" -exec wc -l {} \;            # 확장자가 c 인 파일의 라인 수 출력.
$ ls
A.c  A.h  B.c  B.h
$ find . -name "*.c" -exec wc -l {} \;
312 ./A.c
2456 ./B.c
3.15 검색된 파일에서 문자열 검색. (find + grep)
find 명령과 grep 명령을 조합하여, 검색된 파일로부터 특정 문자열을 찾을 수 있습니다.



$ find . -name "*.c" -exec grep "main" {} \;                # .c 파일에 문자열 main이 있는지 검색.
$ find . -name "*.java" -exec grep -n "class" {} \;         # .java 파일에 문자열 class가 있는 라인 표시.
$ find . -name "*.h" -exec grep -n "include" {} \;
1:#include <stdio.h>
3.16 파일 검색 결과를 파일로 저장. (find, redirection)
find 명령의 결과 내용을 표준 출력이 아닌, 파일로 저장하려면 redirection(>)을 사용합니다.



$ find . -name "*.c" > source-list.txt            # 모든 c 파일 검색 결과를 source-list.txt에 저장.
$ ls
A.c  A.h  B.c  B.h  DIR_1
$ find . -name "*.c" > source-list.txt
$ cat source-list.txt
./A.c
./B.c
3.17 검색 중 에러 메시지 출력하지 않기. (find, redirection)
find 명령을 실행할 때, 실행 결과와 별개로 에러 메시지가 표시되는 경우가 있습니다. 특히 디렉토리 접근 권한 문제로 인해 "Permission denied" 에러 메시지가 화면을 가득채우게 되면, 실제 검색 결과를 확인하기가 어렵게 되죠.



이럴 때 redirection을 통해 에러 메시지를 화면에 표시되지 않게 만들 수 있습니다. 표준 에러(2)를 "/dev/null"로 redirection 시켜버리는 것이죠.

$ find / -name "*.c" 2> /dev/null                 # 에러 메시지를 표시하지 않음.
$ ls
A.c  A.h  B.c  B.h  DIR_1
$ find / -name "A.c"
...
find: ‘/sys/kernel/debug’: Permission denied
/home/ppotta/A.c
find: ‘/sys/fs/pstore’: Permission denied
...
$ find / -name "A.c" 2> /dev/null
/home/ppotta/A.c
3.18 하위 디렉토리 검색하지 않기.
기본적으로 find 명령은 하위 디렉토리까지 모두 탐색합니다. 하지만 "-maxdepth" 표현식을 사용하면 검색할 하위 디렉토리의 깊이를 제한할 수 있습니다. 참고로 "-maxdepth"는 다른 표현식보다 앞에 사용해야 합니다.



$ find / -maxdepth 1 -name "sys"        # sys라는 파일을 루트(/) 디렉토리에서만 검색.
$ find / -name "sys"
find: ‘/root’: Permission denied
find: ‘/var/spool/cups’: Permission denied
...
$ find / -maxdepth 1 -name "sys"
/sys
3.19 검색된 파일 복사. (find + cp)
find 명령과 cp 명령을 조합하여, 검색된 파일을 지정된 디렉토리로 복사할 수 있습니다.



$ find . -name "*.tar.gz" -exec cp {} /mnt/usb/ \;       > tar.gz 파일을 /mnt/usb/ 에 복사.
4. 참고.
Man7 Linux Manual Page - find
[Man7. man. find] 내용을 참고하세요.
.END.


1. grep 명령어.
리눅스 grep 명령어



grep은 입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자할 때 사용하는 명령어입니다. 리눅스에서 가장 많이 사용되는 명령어 중 하나이죠.



하지만 grep 명령어가 문자열을 찾는 기능을 수행한다고 해서, 단순히 문자열이 일치하는지 여부만을 검사하는 것은 아닙니다. 문자열이 같은지(equal)만을 검사하는 수준을 넘어, 훨씬 복잡하고 다양한 방식으로, 그리고 매우 효율적으로 문자열을 찾는 기능을 제공하죠. 이는 grep이 파일의 문자열을 검색할 때, 단순 문자열 매칭이 아니라, 정규 표현식(Regular Expression)에 의한 패턴 매칭(Pattern Matching) 방식을 사용하기 때문입니다.

1.1 정규 표현식(Regular Expression)
정규 표현식(Regular Expression)이란, 특정 규칙을 가진 문자열 집합을 표현하기 위한 형식 언어로써, 주로 문자열 패턴 매칭을 검사하거나 또는 문자열을 치환하기 위해 사용됩니다.



문자열 검색에 정규 표현식을 적용하게 되면, 지정된 문자열의 문자가 단순히 "같은지(equal)" 여부가 검사되는 것이 아니라, 정규 표현식의 규칙에 매칭(Matching)되는지 여부가 검사됩니다.


 


예를 들어, 단순 문자열 검색에서 '*'은 문자 그대로 '*'을 의미하기 때문에, ('*' == '*')은 성립하지만 ('A' == '*')는 성립하지 않습니다. 하지만 정규 표현식에서 '*'는 0개 이상의 모든 문자를 의미하므로, ('*' == '*') 뿐만 아니라 ('A' == '*')도 TRUE로 판단됩니다.



정규 표현식을 모두 설명하려면 지면이 한참 모자라니, 여기서는 정규 표현식을 작성할 때 사용되는 메타 문자(Meta Character)에 대해서만 간략히 정리하겠습니다.



메타 문자
(Meta Character)	설명
.	1개의 문자 매치 (정확히 1개의 문자와 매치)
*	앞 문자가 0회 이상 매치
{n}	앞 문자가 정확히 n회 매치
{n,m}	앞 문자가 n회 이상 m회 이하 매치
[ ]	대괄호에 포함된 문자 중 한개와 매치
[^ ]	대괄호 안에서 ^뒤에 있는 문자들을 제외
[ - ]	대괄호 안 문자 범위에 있는 문자들 매치
()	표현식을 그룹화
^	문자열 라인의 처음
$	문자열 라인의 마지막
?	앞 문자가 0 또는 1회 매치 (확장 정규 표현식)
+	앞 문자가 1회 이상 매치 (확장 정규 표현식)
|	표현식 논리 OR (확장 정규 표현식)
2. grep 명령어 옵션.
grep 명령에서 사용할 수 있는 옵션은 아래와 같습니다. (grep 명령에 대한 더 자세한 옵션은 "grep --help" 명령을 통해 확인할 수 있습니다.)



    grep [OPTION...] PATTERN [FILE...]
        -E        : PATTERN을 확장 정규 표현식(Extended RegEx)으로 해석.
        -F        : PATTERN을 정규 표현식(RegEx)이 아닌 일반 문자열로 해석.
        -G        : PATTERN을 기본 정규 표현식(Basic RegEx)으로 해석.
        -P        : PATTERN을 Perl 정규 표현식(Perl RegEx)으로 해석.
        -e        : 매칭을 위한 PATTERN 전달.
        -f        : 파일에 기록된 내용을 PATTERN으로 사용.
        -i        : 대/소문자 무시.
        -v        : 매칭되는 PATTERN이 존재하지 않는 라인 선택.
        -w        : 단어(word) 단위로 매칭.
        -x        : 라인(line) 단위로 매칭.
        -z        : 라인을 newline(\n)이 아닌 NULL(\0)로 구분.
        -m        : 최대 검색 결과 갯수 제한.
        -b        : 패턴이 매치된 각 라인(-o 사용 시 문자열)의 바이트 옵셋 출력.
        -n        : 검색 결과 출력 라인 앞에 라인 번호 출력.
        -H        : 검색 결과 출력 라인 앞에 파일 이름 표시.
        -h        : 검색 결과 출력 시, 파일 이름 무시.
        -o        : 매치되는 문자열만 표시.
        -q        : 검색 결과 출력하지 않음.
        -a        : 바이너리 파일을 텍스트 파일처럼 처리.
        -I        : 바이너리 파일은 검사하지 않음.
        -d        : 디렉토리 처리 방식 지정. (read, recurse, skip)
        -D        : 장치 파일 처리 방식 지정. (read, skip)
        -r        : 하위 디렉토리 탐색.
        -R        : 심볼릭 링크를 따라가며 모든 하위 디렉토리 탐색.
        -L        : PATTERN이 존재하지 않는 파일 이름만 표시.
        -l        : 패턴이 존재하는 파일 이름만 표시.
        -c        : 파일 당 패턴이 일치하는 라인의 갯수 출력.
3. grep 명령 사용 예제.
grep을 사용하여 파일로부터 문자열을 검색하는 방법은 아래와 같습니다.



$ grep [OPTION] [PATTERN] [FILE]


아래는 "FILE.txt"의 내용에서 "PAT"라는 문자열을 검색하고, 문자열이 존재하는 라인을 출력하는 예제입니다. 기본적으로 대소문자를 구분한다는 점에 주의하세요.



$ cat FILE.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep "PAT" FILE.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
자주 사용하는 grep 명령어 사용 예제는 아래와 같습니다. 각 항목의 링크를 선택하면, 좀 더 자세한 설명과 사용 예제를 확인할 수 있습니다.



grep 사용 예	명령어 옵션
대상 파일에서 문자열 검색	grep "STR" [FILE]
현재 디렉토리 모든 파일에서 문자열 검색	grep "STR" *
특정 확장자를 가진 모든 파일에서 문자열 검색	grep "STR" *.ext
대소문자 구분하지 않고 문자열 검색	grep -i "STR" [FILE]
매칭되는 PATTERN이 존재하지 않는 라인 선택	grep -v "STR" [FILE]
단어(Word) 단위로 문자열 검색	grep -w "STR" [FILE]
검색된 문자열이 포함된 라인 번호 출력	grep -n "STR" [FILE]
하위 디렉토리를 포함한 모든 파일에서 문자열 검색	grep -r "STR" *
최대 검색 결과 갯수 제한	grep -m 100 "STR" FILE
검색 결과 앞에 파일 이름 표시	grep -H "STR" *
문자열 A로 시작하여 문자열 B로 끝나는 패턴 찾기	grep "A.*B" *
0-9 사이 숫자만 변경되는 패턴 찾기	grep "STR[0-9]" *
문자열 패턴 전체를 정규 표현식 메타 문자가 아닌
일반 문자로 검색하기	grep -F "*[]?..." [FILE]
정규 표현식 메타 문자를 일반 문자로 검색하기	grep "\*" [FILE]
문자열 라인 처음 시작 패턴 검색하기	grep "^STR" [FILE]
문자열 라인 마지막 종료 패턴 검색하기	grep "$STR" [FILE]
3.1 대상 파일에서 문자열 검색.
grep 명령에 문자열과 파일 이름을 지정하여, 파일에서 문자열을 검색할 수 있습니다. 이 때 문자열 검색 결과는 문자열이 포함된 라인 단위로 출력됩니다.

$ grep "STR" FILE1.txt         > FILE.txt에서 "STR" 문자열 검색.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep "PAT" FILE.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
3.2 현재 디렉토리 모든 파일에서 문자열 검색
파일 이름에 "*" 문자를 사용하여, 현재 디렉토리에 있는 모든 파일에서 문자열을 검색할 수 있습니다. 단, 현재 디렉토리에 포함된 하위 디렉토리에 있는 파일은 탐색하지 않습니다. (하위 디렉토리를 탐색하려면 -r 옵션 사용.)

$ grep "STR" *                > 현재 디렉토리 모든 파일에서 "STR" 문자열 검색.
$ ls
FILE1.txt  FILE2.txt
$ grep "PAT" *
FILE1.txt:grep searches for PATTERNS in each FILE.
FILE1.txt:PATTERNS is one or patterns separated by newline characters.
FILE2.txt:grep searches for PATTERNS in each FILE.
FILE2.txt:PATTERNS is one or patterns separated by newline characters.
3.3 특정 확장자를 가진 모든 파일에서 문자열 검색
파일 이름 확장자 앞에 "*" 문자를 사용하여, 특정 확장자를 가진 모든 파일에서 문자열을 검색할 수 있습니다.

$ grep "STR" *.ext            > ext 확장자를 가진 파일에서 "STR" 문자열 검색.
$ ls
A.c  A.h  B.c  B.h 
$ grep "include" *.h
A.h:#include <stdio.h>
B.h:#include <string.h"
3.4 대소문자 구분하지 않고 문자열 검색
grep 명령에 "-i" 옵션을 사용하여, 대소문자 구분없이 문자열을 검색할 수 있습니다.

grep -i "STR" FILE.txt        > FILE.txt 파일에서 대소문자 구분없이(STR, str) 문자열 검색.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep -i "Pat" FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
3.5 매칭되는 PATTERN이 존재하지 않는 라인 선택
어떤 경우에는, 문자열이 매칭되는 라인이 아닌, 매칭되는 패턴이 존재하지 않는 라인을 선택해야 하는 경우가 있습니다. 이 때, "-v" 옵션을 사용합니다.

grep -v "STR" FILE.txt        > FILE.txt 파일에서 "STR"이 포함되지 않은 라인 표시.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep -v "PAT" FILE1.txt
And grep prints each line that matches a pattern.
3.6 단어(Word) 단위로 문자열 검색
"-w" 옵션을 사용하면, 단어(Word) 단위로 문자열을 검색할 수 있습니다.

grep -w "STRING" FILE.txt     > FILE.txt 파일에서 "STRING"이라는 문자열(단어 단위) 검색.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep -w "PAT" FILE1.txt
$ grep -w "PATTERNS" FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
3.7 검색된 문자열이 포함된 라인 번호 출력
"-n" 옵션을 사용하여, 검색 결과가 포함된 라인 번호를 출력할 수 있습니다.

grep -n "STR" FILE.txt        > "STR"이 포함된 라인 번호 출력.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep -n "PAT" FILE1.txt
1:grep searches for PATTERNS in each FILE.
2:PATTERNS is one or patterns separated by newline characters.
3.8 하위 디렉토리를 포함한 모든 파일에서 문자열 검색
"-r" 옵션을 사용하면, 하위 디렉토리를 포함한 모든 파일에서 문자열을 검색할 수 있습니다.

grep -r "STR" *               > "STR"이 포함된 라인 번호 출력.
$ grep -r "PAT" *
DIR_1/FILE1.txt:grep searches for PATTERNS in each FILE.
DIR_1/FILE1.txt:PATTERNS is one or patterns separated by newline characters.
FILE1.txt:grep searches for PATTERNS in each FILE.
FILE1.txt:PATTERNS is one or patterns separated by newline characters.
FILE2.txt:grep searches for PATTERNS in each FILE.
FILE2.txt:PATTERNS is one or patterns separated by newline characters.

3.9 최대 검색 결과 갯수 제한
grep 명령의 결과가 너무 많이 표시될 때, "-m" 옵션을 사용하여 최대 표시 결과를 제한할 수 있습니다.

grep -m 100 "STR" FILE.txt    > FILE.txt 파일에서 문자열 "STR"이 포함된 결과를 100개까지만 표시.
$ cat FILE1.txt
grep searches for PATTERNS in each FILE.
PATTERNS is one or patterns separated by newline characters.
And grep prints each line that matches a pattern.
$ grep -n "PAT" FILE1.txt
1:grep searches for PATTERNS in each FILE.
2:PATTERNS is one or patterns separated by newline characters.
$ grep -m 1 "PAT" FILE1.txt
grep searches for PATTERNS in each FILE.
3.10 검색 결과 앞에 파일 이름 표시
"-H" 옵션을 사용하여 검색 결과 앞에 파일 이름을 표시할 수 있습니다.

grep -H "STR" *               > "STR"이 포함된 파일 이름 표시.
grep -Hn "STR" *              > "STR"이 포함된 파일 이름과 라인 번호 표시.
$ grep -H "PAT" *
FILE1.txt:grep searches for PATTERNS in each FILE.
FILE1.txt:PATTERNS is one or patterns separated by newline characters.
$ grep -Hn "PAT" *
FILE1.txt:1:grep searches for PATTERNS in each FILE.
FILE1.txt:2:PATTERNS is one or patterns separated by newline characters.
3.11 문자열 A로 시작하여 문자열 B로 끝나는 패턴 찾기
정규 표현식에서 "."와 "*"를 조합하여 문자열 A로 시작하여 문자열 B로 끝나는 패턴을 찾을 수 있습니다.

grep "the.*step" *            > "the"로 시작하여 "step"으로 끝나는 패턴 검색.
grep "A.*Z" *                 > "A"로 시작하여 "Z"로 끝나는 패턴 검색.
$ cat FILE1.txt
the first step  : edit text file.
the second step : save the file.
the third step  : copy to usb.
$ grep -n "the.*step" FILE1.txt
1:the first step  : edit text file.
2:the second step : save the file.
3:the third step  : copy to usb.
$ cat FILE2.txt
ABCDEFGHIJKLMNOPQRSTUVWXYZ
BCD
XYZ
ABZ
$ grep -n "A.*Z" FILE2.txt
1:ABCDEFGHIJKLMNOPQRSTUVWXYZ
4:ABZ
3.12 [0-9] 사이 숫자만 변경되는 패턴 찾기
정규 표현식 "[]"를 사용하여 0-9 사이 숫자만 변경되는 문자열 패턴을 검색할 수 있습니다.

grep step[0-9] *              > "step0", "step1", ..., "step9" 패턴을 검색.
$ cat FILE3.txt
step0  : edit text file.
step1  : save the file.
step2  : copy to usb.
$ grep -n step[0-9] FILE3.txt
1:step0  : edit text file.
2:step1  : save the file.
3:step2  : copy to usb.
3.13 문자열 패턴 전체를 정규 표현식 메타 문자가 아닌 일반 문자로 검색하기
"-F" 옵션을 사용하면, 패턴에 지정된 문자열을 메타 문자로 인식하지 않고 일반 문자로 인식하여 패턴을 검색합니다.

grep -f "[0-9]" *             > "[0-9]" 문자열 검색.
$ cat FILE4.txt
01234567890
[0-9]
12345
$ grep -n "[0-9]" FILE4.txt
1:01234567890
2:[0-9]
3:12345
$ grep -Fn "[0-9]" FILE4.txt
2:[0-9]
3.14 정규 표현식 메타 문자를 일반 문자로 검색하기
문자열 패턴에서 정규 표현식 메타 문자 앞에 "\"(백슬래시)를 사용하면, 해당 문자를 일반 문자로 인식하게 만들 수 있습니다.

grep "\*" FILE.txt            > FILE.txt 파일에서 * 문자 검색.
grep "\." FILE.txt            > FILE.txt 파일에서 . 문자 검색.
$ cat FILE5.txt
* step 1
1. sample text 1
2. sample text 2
$ grep "\*" FILE5.txt
* step 1
$ grep "." FILE5.txt
* step 1
1. sample text 1
2. sample text 2
$ grep "\." FILE5.txt
1. sample text 1
2. sample text 2
3.15 문자열 라인의 처음 시작 패턴 검색하기.
정규 표현식 "^"를 사용하여 문자열 라인의 중간이 아닌 시작 패턴만 검색할 수 있습니다.

grep "^C" FILE.txt            > FILE.txt 에서 C로 시작하는 라인 검색.
grep "^1" FILE.txt            > FILE.txt 에서 "1"으로 시작하는 라인 검색.
$ cat FILE5.txt
* step 1
1. sample text 1
2. sample text 2
$ grep "^1" FILE5.txt
1. sample text 1
3.16 문자열 라인 마지막 종료 패턴 검색하기.
정규 표현식 "$"를 사용하여 문자열 라인의 처음 또는 중간이 아닌 종료 패턴을 검색할 수 있습니다.

grep "\.$" FILE.txt           > FILE.txt "." 으로 끝나는 라인 검색.
grep -v "\.$" FILE.txt        > FILE.txt "." 으로 끝나지 않는 라인 검색.
$ cat FILE6.txt
..............
.............?
ABCDEFGHIJKLM.
$ grep "\.$" FILE6.txt
..............
ABCDEFGHIJKLM.
$ grep -v "\.$" FILE6.txt
.............?
4. 참고.
Man7 Linux Manual Page - grep
[Man7. man. grep] 내용을 참고하세요.
Wiki - 정규 표현식 (Regular Expression)
[Wiki - 정규 표현식] 내용을 참고하세요.
.END.